package io.github.dubthree.mutantkiller.codegen;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import io.github.dubthree.mutantkiller.analysis.MutantAnalysis;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Represents a proposed test improvement with the ability to apply it.
 */
public class TestImprovement {

    private final MutantAnalysis analysis;
    private final String generatedCode;
    private final boolean dryRun;

    public TestImprovement(MutantAnalysis analysis, String generatedCode, boolean dryRun) {
        this.analysis = analysis;
        this.generatedCode = generatedCode;
        this.dryRun = dryRun;
    }

    /**
     * Returns a diff-like representation of the proposed change.
     */
    public String diff() {
        StringBuilder diff = new StringBuilder();
        diff.append("=== Proposed Test Improvement ===\n");
        diff.append("Target: ").append(analysis.testFile() != null ? analysis.testFile() : "NEW TEST FILE").append("\n");
        diff.append("For mutation: ").append(analysis.mutation().humanReadable()).append("\n");
        diff.append("\n+++ New/Modified Code +++\n");
        diff.append(generatedCode);
        diff.append("\n");
        return diff.toString();
    }

    /**
     * Apply the improvement to the test file.
     */
    public void apply() throws IOException {
        if (dryRun) {
            System.out.println("(dry run - not applying changes)");
            return;
        }

        if (analysis.hasExistingTest()) {
            applyToExistingTest();
        } else {
            createNewTestFile();
        }
    }

    private void applyToExistingTest() throws IOException {
        Path testFile = analysis.testFile();
        String existingCode = analysis.existingTestCode();

        // Parse existing test
        CompilationUnit cu = StaticJavaParser.parse(existingCode);
        
        // Parse the generated method(s)
        // Wrap in a class if necessary for parsing
        String wrappedCode = "class Temp { " + generatedCode + " }";
        CompilationUnit generated;
        try {
            generated = StaticJavaParser.parse(wrappedCode);
        } catch (Exception e) {
            // If parsing fails, try to add the code as-is
            String updatedCode = appendToTestClass(existingCode, generatedCode);
            Files.writeString(testFile, updatedCode);
            return;
        }

        // Find the test class in the existing file
        ClassOrInterfaceDeclaration testClass = cu.findFirst(ClassOrInterfaceDeclaration.class)
            .orElseThrow(() -> new IOException("Could not find test class"));

        // Add each generated method to the test class
        generated.findAll(MethodDeclaration.class).forEach(method -> {
            // Check if method already exists
            String methodName = method.getNameAsString();
            boolean exists = testClass.getMethodsByName(methodName).size() > 0;
            
            if (exists) {
                // Replace existing method
                testClass.getMethodsByName(methodName).get(0).replace(method);
            } else {
                // Add new method
                testClass.addMember(method.clone());
            }
        });

        // Write back
        Files.writeString(testFile, cu.toString());
    }

    private String appendToTestClass(String existingCode, String newMethods) {
        // Find the last closing brace of the class and insert before it
        int lastBrace = existingCode.lastIndexOf('}');
        if (lastBrace > 0) {
            return existingCode.substring(0, lastBrace) + 
                   "\n    // Generated by mutant-killer\n" +
                   indentCode(newMethods, 4) + 
                   "\n" +
                   existingCode.substring(lastBrace);
        }
        return existingCode + "\n" + newMethods;
    }

    private void createNewTestFile() throws IOException {
        String className = analysis.mutation().mutatedClass();
        int lastDot = className.lastIndexOf('.');
        String simpleClassName = lastDot >= 0 ? className.substring(lastDot + 1) : className;
        String packageName = lastDot >= 0 ? className.substring(0, lastDot) : null;

        StringBuilder testClass = new StringBuilder();
        if (packageName != null) {
            testClass.append("package ").append(packageName).append(";\n\n");
        }
        testClass.append("import org.junit.jupiter.api.Test;\n");
        testClass.append("import static org.junit.jupiter.api.Assertions.*;\n\n");
        testClass.append("/**\n * Tests generated by mutant-killer to improve mutation coverage.\n */\n");
        testClass.append("class ").append(simpleClassName).append("Test {\n\n");
        testClass.append(indentCode(generatedCode, 4));
        testClass.append("\n}\n");

        // Determine path using the test directory from the analysis config
        Path testDir;
        if (packageName != null) {
            String packagePath = packageName.replace('.', '/');
            testDir = Path.of("src/test/java").resolve(packagePath);
        } else {
            testDir = Path.of("src/test/java");
        }

        Files.createDirectories(testDir);
        Path testFile = testDir.resolve(simpleClassName + "Test.java");
        Files.writeString(testFile, testClass.toString());

        System.out.println("Created new test file: " + testFile);
    }

    private String indentCode(String code, int spaces) {
        String indent = " ".repeat(spaces);
        return code.lines()
            .map(line -> line.isEmpty() ? line : indent + line)
            .reduce((a, b) -> a + "\n" + b)
            .orElse(code);
    }

    public String generatedCode() {
        return generatedCode;
    }
}
